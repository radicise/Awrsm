#!/bin/awk -f
BEGIN {
	insns["ADC"] = "";
	insns["ADD"] = "";
	insns["AND"] = "";
	insns["B"] = "";
	insns["BIC"] = "";
	insns["BKPT"] = "";
	insns["BL"] = "";
	insns["BLX_1"] = "";
	insns["BLX_2"] = "";
	insns["BX"] = "";
	insns["BXJ"] = "";
	insns["CDP"] = "";
	insns["CDP2"] = "";
	insns["CLZ"] = "";
	insns["CMN"] = "";
	insns["CMP"] = "";
	insns["CPS"] = "";
	insns["CPY"] = "";
	insns["EOR"] = "";
	insns["LDC"] = "";
	insns["LDC2"] = "";
	insns["LDM_1"] = "";
	insns["LDM_2"] = "";
	insns["LDM_3"] = "";
	insns["LDR"] = "";
	insns["LDRB"] = "";
	insns["LDRD"] = "";
	insns["LDRBT"] = "";
	insns["LDREX"] = "";
	insns["LDRH"] = "";
	insns["LDRSB"] = "";
	insns["LDRSH"] = "";
	insns["LDRT"] = "";
	insns["MCR"] = "";
	insns["MCR2"] = "";
	insns["MCRR"] = "";
	insns["MCRR2"] = "";
	insns["MLA"] = "";
	insns["MOV"] = "cond:0-4:0;b00::X;shifter_operand:12-13:5;b1101::X;S:0-1:1;b0000::X;Rd:0-4:4;shifter_operand:0-12:5";
	insns["MRC"] = "";
	insns["MCR2"] = "";
	insns["MRRC"] = "";
	insns["MRRC2"] = "";
	insns["MRS"] = "";
	insns["MSR"] = "";
	insns["MUL"] = "";
	insns["MVN"] = "";
	insns["ORR"] = "";
	insns["PKHBT"] = "";
	insns["PKHTB"] = "";
	insns["PLD"] = "";
	insns["QADD"] = "";
	insns["QADD16"] = "";
	insns["QADD8"] = "";
	insns["QADDSUBX"] = "";
	insns["QDADD"] = "";
	insns["QDSUB"] = "";
	insns["QSUB"] = "";
	insns["QSUB16"] = "";
	insns["QSUB8"] = "";
	insns["QSUBADDX"] = "";
	insns["REV"] = "";
	insns["REV16"] = "";
	insns["REVSH"] = "";
	insns["RFE"] = "";
	insns["RSB"] = "";
	insns["RSC"] = "";
	insns["SADD16"] = "";
	insns["SADD8"] = "";
	insns["SADDSUBX"] = "";
	insns["SBC"] = "";
	insns["SEL"] = "";
	insns["SETEND"] = "";
	insns["SHADD16"] = "";
	insns["SHADD8"] = "";
	insns["SHADDSUBX"] = "";
	insns["SHSUB16"] = "";
	insns["SHSUB8"] = "";
	insns["SHSUBADDX"] = "";
	insns["SMLAD"] = "";
	insns["SMLAL"] = "";
	insns["SMLALD"] = "";
	insns["SMLABB"] = "";
	insns["SMLABT"] = "";
	insns["SMLATB"] = "";
	insns["SMLATT"] = "";
	insns["SMLALBB"] = "";
	insns["SMLALBT"] = "";
	insns["SMLALTB"] = "";
	insns["SMLALTT"] = "";
	insns["SMLAWB"] = "";
	insns["SMLAWT"] = "";
	insns["SMLSD"] = "";
	insns["SMLSLD"] = "";
	insns["SMMLA"] = "";
	insns["SMMLS"] = "";
	insns["SMMUL"] = "";
	insns["SMUAD"] = "";
	insns["SMULL"] = "";
	insns["SMUL"] = "";
	insns["SMULBB"] = "";
	insns["SMULBT"] = "";
	insns["SMULTB"] = "";
	insns["SMULTT"] = "";
	insns["SMULWB"] = "";
	insns["SMULWT"] = "";
	insns["SMUSD"] = "";
	insns["SRS"] = "";
	insns["SSAT"] = "";
	insns["SSAT16"] = "";
	insns["SSUB16"] = "";
	insns["SSUB8"] = "";
	insns["SSUBADDX"] = "";
	insns["STC"] = "";
	insns["STC2"] = "";
	insns["STM_1"] = "";
	insns["STM_2"] = "";
	insns["STR"] = "";
	insns["STRB"] = "";
	insns["STRBT"] = "";
	insns["STRD"] = "";
	insns["STREX"] = "";
	insns["STRH"] = "";
	insns["STRT"] = "";
	insns["SUB"] = "";
	insns["SWI"] = "";
	insns["SWP"] = "";
	insns["SWPB"] = "";
	insns["SXTAB"] = "";
	insns["SXTAB16"] = "";
	insns["SXTAH"] = "";
	insns["SXTB"] = "";
	insns["SXTB16"] = "";
	insns["SXTH"] = "";
	insns["TEQ"] = "";
	insns["TST"] = "";
	insns["UADD16"] = "";
	insns["UADD8"] = "";
	insns["UADDSUBX"] = "";
	insns["UHADD16"] = "";
	insns["UHADD8"] = "";
	insns["UHADDSUBX"] = "";
	insns["UMAAL"] = "";
	insns["UMLAL"] = "";
	insns["UMULL"] = "";
	insns["UQADD16"] = "";
	insns["UQADD8"] = "";
	insns["UQADDSUBX"] = "";
	insns["UQSUB16"] = "";
	insns["UQSUB8"] = "";
	insns["UQSUBADDX"] = "";
	insns["USAD8"] = "";
	insns["USADA8"] = "";
	insns["USAT"] = "";
	insns["USAT16"] = "";
	insns["USUB16"] = "";
	insns["USUB8"] = "";
	insns["USUBADDX"] = "";
	insns["UXTAB"] = "";
	insns["UXTAB16"] = "";
	insns["UXTAH"] = "";
	insns["UXTB"] = "";
	insns["UXTB16"] = "";
	insns["UXTH"] = "";
	forms["shifter_operand"] = 1;
	forms["S"] = 2;
	forms["Rd"] = 3;
	forms["cond"] = 4;
	conds["EQ"] = "0000";
	conds["NE"] = "0001";
	conds["CS"] = "0010";
	conds["HS"] = "0010";
	conds["CC"] = "0011";
	conds["LO"] = "0011";
	conds["MI"] = "0100";
	conds["PL"] = "0101";
	conds["VS"] = "0110";
	conds["VC"] = "0111";
	conds["HI"] = "1000";
	conds["LS"] = "1001";
	conds["GE"] = "1010";
	conds["LT"] = "1011";
	conds["GT"] = "1100";
	conds["LE"] = "1101";
	conds["AL"] = "1110";
	hexAlphas["A"] = 10;
	hexAlphas["B"] = 11;
	hexAlphas["C"] = 12;
	hexAlphas["D"] = 13;
	hexAlphas["E"] = 14;
	hexAlphas["F"] = 15;
}
NF {
	for (a = $1; a; a = substr(a, 1, length(a) - 1)) {
		if (asUpper(a) in insns) {
			break;
		}
	}
	if (!a) {
		exit(1);
	}
	a = asUpper(a);
	if (!(insns[a])) {
		exit(1);
	}
	split(insns[a], b, ";");
	form = substr($0, length(a) + 1);
	split("", e);
	split("", h);
	lexNum = 0;
	for (pos in b) {
		lex = substr(b[pos], length(b[pos]), 1);
		if ((lex - 3) > lexNum) {
			lexNum = lex - 3;
		}
		if (lex in e) {
			h[pos] = b[pos];
		}
		else {
			e[lex] = b[pos] ":" (pos + 10);
		}
	}
	for (lex = 0; 1; lex++) {
		if (lex == 10) {
			if ("X" in e) {
				lex = "X";
				pos = substr(e[lex], length(e[lex]) - 1, 2) - 10;
				if (substr(e[lex], 1, 1) == "b") {
					b[pos] = substr(e[lex], 2, length(e[lex]) - 7);
				}
				else {
					exit(105);
				}
			}
			break;
		}
		if (!(lex in e)) {
			continue;
		}
		pos = substr(e[lex], length(e[lex]) - 1, 2) - 10;
		b[pos] = parseForm(a, e[lex]);
	}
	for (pos in h) {
		if (substr(h[pos], 1, 1) == "b") {
			b[pos] = substr(h[pos], 2, length(h[pos]) - 4);
			continue;
		}
		lex = substr(h[pos], length(h[pos]), 1);
		split(h[pos], y, ":");
		if (!(3 in y)) {
			exit(101);
		}
		t1 = y[2];
		split(t1, y, "-");
		if (!(2 in y)) {
			exit(102);
		}
		seq = b[substr(e[lex], length(e[lex]) - 1, 2) - 10];
		b[pos] = substr(seq, length(seq) + 1 - (y[2] - y[1]) - y[1], y[2] - y[1]);
	}
	for (lex in e) {
		if (substr(e[lex], 1, 1) == "b") {
			continue;
		}
		seq = b[pos = (substr(e[lex], length(e[lex]) - 1, 2) - 10)];
		split(e[lex], y, ":");
		if (!(4 in y)) {
			exit(103);
		}
		t1 = y[2];
		split(t1, y, "-");
		if (!(2 in y)) {
			exit(104);
		}
		b[pos] = substr(seq, length(seq) + 1 - (y[2] - y[1]) - y[1], y[2] - y[1]);
	}
	c = "";
	pos = 0;
	while ((++pos) in b) {
		c = c b[pos];
	}
	print(c);
}
function parseForm(insn, fieldDef) {
	split(fieldDef, p1, ":");
	if (!(4 in p1)) {
		exit(106);
	}
	if (p1[3] >= 4) {
		FS = ","#TODO Account for commas in addressing forms
		$0 = form;
		$1 = $1;#TODO Is this necessary?
		if (NF < (p1[3] - 3)) {
			exit(1);
		}
		if ((p1[3] - 3) == lexNum) {
			n1 = $(lexNum);
			for (n2 = lexNum + 1; n2 <= NF; n2++) {
				n1 = n1 "," $(n2);
			}
		}
		else if ((p1[3] - 3) < lexNum) {
			n1 = $(p1[3] - 3);
		}
		else {
			exit(107);
		}
		FS = " ";
		$0 = n1;
		$1 = $1;#TODO Is this necessary?
		txt = $0;
	}
	if (!(p1[1] in forms)) {
		exit(107);
	}
	n1 = forms[p1[1]];
	if (n1 == 1) {
		if (substr(txt, 1, 1) == "#") {
			nImm = getImm(txt, 2);
			exit(99);
			return "0000000000000000000000000";#TODO implement
		}
		n2 = asBin(getReg(txt, 1), 4);
		if (txt ~ /,/) {
			exit(99);
			return "00000000000000000000000"#TODO implement
		}
		return "000000000" n2;
	}
	else if (n1 == 2) {
		if (asUpper(substr(form, 1, 1)) == "S") {
			form = substr(form, 2);
			return "1";
		}
		return "0";
	}
	else if (n1 == 3) {
		return asBin(getReg(txt, 1), 4);
	}
	else if (n1 == 4) {
		if ((n2 = asUpper(substr(form, 1, 2))) in conds) {
			form = substr(form, 3);
			return conds[n2];
		}
		return "1110";
	}
	else {
		exit(108);
	}
}
function asUpper(s) {
	return toupper(s);
}
function asBin(a, b) {
	a = int(a + 0);#TODO Is the addition of zero necessary?
	binRes = "";
	for (; b != 0; b--) {
		binRes = (a % 2) binRes;
		a = int(a / 2);
	}
	return binRes;
}
function getImm(strImm, place) {
	if ((immDig = substr(strImm, place, 1)) == 0) {
		if (asUpper(immDig = substr(strImm, ++place, 1)) == "X") {
			immRes = 0;
			while ((immDig = asUpper(substr(strImm, ++place, 1))) ~ /[0123456789ABCDEF]/) {
				immRes = (immRes * 16) + ((immDig ~ /[ABCDEF]/) ? (hexAlphas[immDig]) : (immDig));
			}
			return immRes;
		}
		else if (immDig ~ /[01234567]/) {
			immRes = immDig + 0;
			while ((immDig = substr(strImm, ++place, 1)) ~ /[01234567]/) {
				immRes = (immRes * 8) + immDig;
			}
			return immRes;
		}
		else if (asUpper(immDig) == "B") {
			immRes = 0;
			while ((immDig = substr(strImm, ++place, 1)) ~ /[01]/) {
				immRes = (immRes * 2) + immDig;
			}
			return immRes;
		}
		else {
			return 0;
		}
	}
	else if (immDig ~ /[123456789]/) {
		immRes = immDig + 0;
		while ((immDig = substr(strImm, ++place, 1)) ~ /[0123456789]/) {
			immRes = (immRes * 10) + immDig;
		}
		return immRes;
	}
}
function getReg(strReg, place) {
		if (!(asUpper(substr(strReg, place, 1)) == "R")) {
			exit(1);
		}
		if ((reg2 = getImm(txt, place + 1)) < 0) {
			exit(1);
		}
		if (reg2 >= 16) {
			exit(1);
		}
		return reg2;
}
